name: Build & Sign ZXP

on:
  workflow_dispatch:
    inputs:
      panel_path:
        description: "Path (in repo) to extension root containing CSXS/manifest.xml"
        required: true
        default: "com.sync.extension.ppro.panel"
      tsa_url:
        description: "Timestamp server URL"
        required: true
        default: "http://timestamp.digicert.com"
  push:
    tags:
      - "v*"

jobs:
  build_mac:
    runs-on: macos-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'server/package-lock.json'

      - name: Install server deps (production only)
        working-directory: server
        run: npm ci --omit=dev

      - name: Create .env file from secrets
        shell: bash
        run: |
          set -euo pipefail
          cat > .env << EOF
          # R2 Configuration
          R2_ENDPOINT_URL=${{ secrets.R2_ENDPOINT_URL }}
          R2_ACCESS_KEY=${{ secrets.R2_ACCESS_KEY }}
          R2_SECRET_KEY=${{ secrets.R2_SECRET_KEY }}
          R2_BUCKET=${{ secrets.R2_BUCKET }}
          R2_PREFIX=${{ secrets.R2_PREFIX }}
          # PostHog Configuration
          POSTHOG_KEY=${{ secrets.POSTHOG_KEY }}
          POSTHOG_HOST=${{ secrets.POSTHOG_HOST }}
          EOF
          echo "Created .env file:"
          ls -la .env
          echo "Contents:"
          cat .env
          
          # Validate .env file exists and contains required variables
          if [ ! -f .env ]; then
            echo "ERROR: .env file was not created"
            exit 1
          fi
          
          # Check for required R2 variables
          if ! grep -q "R2_ENDPOINT_URL=" .env || ! grep -q "R2_ACCESS_KEY=" .env || ! grep -q "R2_SECRET_KEY=" .env; then
            echo "ERROR: .env file missing required R2 configuration variables"
            exit 1
          fi
          
          # Ensure variables are not empty
          if grep -q "R2_ACCESS_KEY=$" .env || grep -q "R2_SECRET_KEY=$" .env; then
            echo "ERROR: .env file contains empty R2 credentials"
            exit 1
          fi
          
          echo "✅ .env file validation passed"
          
          # Move .env to server/.env before copying server directory
          # Server runs with cwd=server/, so .env must be in server/.env
          mkdir -p server || { echo "ERROR: Failed to create server directory"; exit 1; }
          cp .env server/.env || { echo "ERROR: Failed to copy .env to server/.env"; exit 1; }
          if [ ! -f server/.env ]; then
            echo "ERROR: server/.env file was not created"
            exit 1
          fi
          echo "✅ Moved .env to server/.env"

      - name: Build CEP folders for macOS
        shell: bash
        run: |
          set -euo pipefail
          macRoot="build/mac"
          ae_mac="$macRoot/com.sync.extension.ae.panel"
          pp_mac="$macRoot/com.sync.extension.ppro.panel"

          rm -rf "$macRoot"
          mkdir -p "$ae_mac" "$pp_mac"

          copy_panel() {
            dest="$1"; src="$2"
            mkdir -p "$dest"
            cp -a "$src/." "$dest/"
            cp -a server "$dest/server"
            cp -a icons "$dest/icons"
            cp -a lib "$dest/lib"
            cp -a bin "$dest/bin"
            cp -a index.html "$dest/"
            cp -a host "$dest/host"
            # Note: .env is copied as part of server/ directory copy above
            # Server runs with cwd=server/, so .env must be in server/.env
            mkdir -p "$dest/ui"
            # Copy shared UI but do NOT overwrite per-extension host-detection.js
            if command -v rsync >/dev/null 2>&1; then
              rsync -a --exclude 'host-detection.js' ui/ "$dest/ui/"
            else
              # Fallback if rsync is unavailable
              find ui -type f ! -name 'host-detection.js' -print0 | while IFS= read -r -d '' f; do
                rel="${f#ui/}"; mkdir -p "$(dirname "$dest/ui/$rel")"; cp -a "$f" "$dest/ui/$rel";
              done
            fi
            # Ensure the extension's own host-detection.js remains
            if [ -f "$src/ui/host-detection.js" ]; then cp -a "$src/ui/host-detection.js" "$dest/ui/host-detection.js"; fi
          }

          copy_panel "$ae_mac"  "extensions/ae-extension"
          copy_panel "$pp_mac"  "extensions/premiere-extension"

          # Strip Windows bins from mac packages
          rm -rf "$ae_mac/bin/win32-x64" "$pp_mac/bin/win32-x64" || true
          
          # Verify .env files were copied correctly (server runs with cwd=server/, so .env must be in server/.env)
          echo "Verifying .env files in built packages..."
          for pkg in "$ae_mac" "$pp_mac"; do
            echo "Checking $pkg/server/.env..."
            if [ ! -f "$pkg/server/.env" ]; then
              echo "ERROR: .env file missing in $pkg/server/"
              exit 1
            fi
            if ! grep -q "R2_ACCESS_KEY=" "$pkg/server/.env" || ! grep -q "R2_SECRET_KEY=" "$pkg/server/.env"; then
              echo "ERROR: .env file missing R2 credentials in $pkg/server/"
              exit 1
            fi
            echo "✅ $pkg/server/.env verified"
          done

      - name: Upload mac build
        uses: actions/upload-artifact@v4
        with:
          name: mac-build
          path: build/mac

  sign:
    needs: [build_mac]
    runs-on: windows-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'server/package-lock.json'

      - name: Install server deps (production only)
        shell: bash
        working-directory: server
        run: npm ci --omit=dev

      - name: Create .env file from secrets
        shell: bash
        run: |
          set -euo pipefail
          cat > .env << EOF
          # R2 Configuration
          R2_ENDPOINT_URL=${{ secrets.R2_ENDPOINT_URL }}
          R2_ACCESS_KEY=${{ secrets.R2_ACCESS_KEY }}
          R2_SECRET_KEY=${{ secrets.R2_SECRET_KEY }}
          R2_BUCKET=${{ secrets.R2_BUCKET }}
          R2_PREFIX=${{ secrets.R2_PREFIX }}
          # PostHog Configuration
          POSTHOG_KEY=${{ secrets.POSTHOG_KEY }}
          POSTHOG_HOST=${{ secrets.POSTHOG_HOST }}
          EOF
          echo "Created .env file:"
          ls -la .env
          echo "Contents:"
          cat .env
          
          # Validate .env file exists and contains required variables
          if [ ! -f .env ]; then
            echo "ERROR: .env file was not created"
            exit 1
          fi
          
          # Check for required R2 variables
          if ! grep -q "R2_ENDPOINT_URL=" .env || ! grep -q "R2_ACCESS_KEY=" .env || ! grep -q "R2_SECRET_KEY=" .env; then
            echo "ERROR: .env file missing required R2 configuration variables"
            exit 1
          fi
          
          # Ensure variables are not empty
          if grep -q "R2_ACCESS_KEY=$" .env || grep -q "R2_SECRET_KEY=$" .env; then
            echo "ERROR: .env file contains empty R2 credentials"
            exit 1
          fi
          
          echo "✅ .env file validation passed"
          
          # Move .env to server/.env before copying server directory
          # Server runs with cwd=server/, so .env must be in server/.env
          mkdir -p server || { echo "ERROR: Failed to create server directory"; exit 1; }
          cp .env server/.env || { echo "ERROR: Failed to copy .env to server/.env"; exit 1; }
          if [ ! -f server/.env ]; then
            echo "ERROR: server/.env file was not created"
            exit 1
          fi
          echo "✅ Moved .env to server/.env"

      - name: Build CEP folders for Windows
        shell: pwsh
        run: |
          # Create build root for windows packages
          $winRoot = "build/win"
          $ae_win  = Join-Path $winRoot "com.sync.extension.ae.panel"
          $pp_win  = Join-Path $winRoot "com.sync.extension.ppro.panel"
          
          # Clean existing folders
          foreach ($p in @($winRoot,$ae_win,$pp_win)) {
            if (Test-Path $p) { Remove-Item $p -Recurse -Force }
          }
          
          # Create build directories
          New-Item -ItemType Directory -Force -Path $winRoot | Out-Null
          
          # Helper to copy a panel skeleton
          function Copy-Panel($dest, $extSrc) {
            # Create destination directory
            New-Item -ItemType Directory -Force -Path $dest | Out-Null
            # Copy extension contents into destination
            Copy-Item "$extSrc/*" $dest -Recurse
            # Then add shared files (don't copy ui since extensions already have their own)
            Copy-Item "server" "$dest/server" -Recurse
            Copy-Item "icons" "$dest/icons" -Recurse
            Copy-Item "lib" "$dest/lib" -Recurse
            Copy-Item "bin" "$dest/bin" -Recurse
            Copy-Item "index.html" "$dest/"
            Copy-Item "host" "$dest/host" -Recurse
            # Note: .env is copied as part of server/ directory copy above
            # Server runs with cwd=server/, so .env must be in server/.env
            if (-not (Test-Path "$dest/server/.env")) { throw ".env file not found in server/ directory for $dest" }
            # Copy main UI files to the existing ui directory (merge, don't replace)
            Copy-Item "ui/*" "$dest/ui/" -Recurse -Force
            # Restore per-extension host-detection.js after shared UI copy
            $extHost = Join-Path $extSrc "ui/host-detection.js"
            $destHost = Join-Path $dest "ui/host-detection.js"
            if (Test-Path $extHost) { Copy-Item $extHost $destHost -Force }
          }
          
          # Build Windows variants (strip darwin bins)
          Copy-Panel $ae_win  "extensions/ae-extension"
          Copy-Panel $pp_win  "extensions/premiere-extension"
          foreach ($dest in @($ae_win,$pp_win)) {
            Remove-Item "$dest/bin/darwin-arm64" -Recurse -Force -ErrorAction SilentlyContinue
            Remove-Item "$dest/bin/darwin-x64" -Recurse -Force -ErrorAction SilentlyContinue
          }

          echo "Created CEP folders (Windows): $ae_win, $pp_win"
          
          # Verify .env files were copied correctly (server runs with cwd=server/, so .env must be in server/.env)
          echo "Verifying .env files in Windows packages..."
          foreach ($pkg in @($ae_win, $pp_win)) {
            echo "Checking $pkg\server\.env..."
            if (-not (Test-Path "$pkg\server\.env")) {
              throw ".env file missing in $pkg\server\"
            }
            $envContent = Get-Content "$pkg\server\.env" -Raw
            if (-not ($envContent -match "R2_ACCESS_KEY=") -or -not ($envContent -match "R2_SECRET_KEY=")) {
              throw ".env file missing R2 credentials in $pkg\server\"
            }
            echo "✅ $pkg\server\.env verified"
          }

      - name: Download mac build
        uses: actions/download-artifact@v4
        with:
          name: mac-build
          path: build/mac
          
      - name: Debug downloaded macOS directories
        shell: powershell
        run: |
          echo "Checking downloaded macOS directories..."
          echo "AE macOS directory exists: $(Test-Path "build\mac\com.sync.extension.ae.panel")"
          echo "Premiere macOS directory exists: $(Test-Path "build\mac\com.sync.extension.ppro.panel")"
          echo "AE macOS .env exists: $(Test-Path "build\mac\com.sync.extension.ae.panel\.env")"
          echo "Premiere macOS .env exists: $(Test-Path "build\mac\com.sync.extension.ppro.panel\.env")"
          
          echo "Contents of AE macOS directory:"
          Get-ChildItem "build\mac\com.sync.extension.ae.panel" | Select-Object Name, Length
          echo "Contents of Premiere macOS directory:"
          Get-ChildItem "build\mac\com.sync.extension.ppro.panel" | Select-Object Name, Length
          
          echo "Searching for .env files recursively in build\mac:"
          Get-ChildItem "build\mac" -Recurse -Name "*.env" | ForEach-Object { echo "Found .env at: $_" }
          
          echo "Searching for any files starting with dot in build\mac:"
          Get-ChildItem "build\mac" -Recurse -Force | Where-Object { $_.Name -like ".*" } | ForEach-Object { echo "Found hidden file: $($_.FullName)" }
          
          # Search for .env files recursively in the downloaded artifact
          echo "Searching for .env files in downloaded artifact..."
          Get-ChildItem "build\mac" -Recurse -Name ".env" -Force
          
          # If .env files are found elsewhere, copy them to the correct locations
          $aeEnvPath = Get-ChildItem "build\mac" -Recurse -Name ".env" -Force | Where-Object { $_ -like "*ae*" } | Select-Object -First 1
          $ppEnvPath = Get-ChildItem "build\mac" -Recurse -Name ".env" -Force | Where-Object { $_ -like "*ppro*" } | Select-Object -First 1
          
          if ($aeEnvPath) {
            echo "Found AE .env at: $aeEnvPath"
            Copy-Item "build\mac\$aeEnvPath" "build\mac\com.sync.extension.ae.panel\.env" -Force
            echo "Copied .env to AE macOS directory"
          }
          
          if ($ppEnvPath) {
            echo "Found Premiere .env at: $ppEnvPath"
            Copy-Item "build\mac\$ppEnvPath" "build\mac\com.sync.extension.ppro.panel\.env" -Force
            echo "Copied .env to Premiere macOS directory"
          }
          
          # Verify .env files are now present
          echo "Final verification:"
          echo "AE macOS .env exists: $(Test-Path "build\mac\com.sync.extension.ae.panel\.env")"
          echo "Premiere macOS .env exists: $(Test-Path "build\mac\com.sync.extension.ppro.panel\.env")"
          
          # Since .env files are missing from the artifact, recreate them in server/.env
          echo "Recreating .env files for macOS packages in server/.env..."
          $envContent = "# R2 Configuration`nR2_ENDPOINT_URL=${{ secrets.R2_ENDPOINT_URL }}`nR2_ACCESS_KEY=${{ secrets.R2_ACCESS_KEY }}`nR2_SECRET_KEY=${{ secrets.R2_SECRET_KEY }}`nR2_BUCKET=${{ secrets.R2_BUCKET }}`nR2_PREFIX=${{ secrets.R2_PREFIX }}`n# PostHog Configuration`nPOSTHOG_KEY=${{ secrets.POSTHOG_KEY }}`nPOSTHOG_HOST=${{ secrets.POSTHOG_HOST }}"
          
          # Create server directory if it doesn't exist and write .env file there
          $aeServerDir = "build\mac\com.sync.extension.ae.panel\server"
          $ppServerDir = "build\mac\com.sync.extension.ppro.panel\server"
          New-Item -ItemType Directory -Force -Path $aeServerDir | Out-Null
          New-Item -ItemType Directory -Force -Path $ppServerDir | Out-Null
          
          $envContent | Out-File -FilePath "$aeServerDir\.env" -Encoding UTF8
          $envContent | Out-File -FilePath "$ppServerDir\.env" -Encoding UTF8
          
          echo "Recreated .env files for both macOS packages in server/.env"
          echo "AE macOS server/.env exists: $(Test-Path "$aeServerDir\.env")"
          echo "Premiere macOS server/.env exists: $(Test-Path "$ppServerDir\.env")"

      - name: Fetch ZXPSignCmd
        shell: pwsh
        run: |
          git clone --depth=1 https://github.com/Adobe-CEP/CEP-Resources.git
          
          # Try multiple versions
          $versions = @("4.1.103", "4.1.102", "4.1.101", "4.1.100")
          $Exe = $null
          
          foreach ($version in $versions) {
            $testPath = "$env:GITHUB_WORKSPACE\CEP-Resources\ZXPSignCMD\$version\win64\ZXPSignCmd.exe"
            if (Test-Path $testPath) {
              $Exe = $testPath
              echo "Using ZXPSignCmd version: $version"
              break
            }
          }
          
          if (-not $Exe) { throw "ZXPSignCmd.exe not found in any version" }
          echo "ZXPSignCmd at: $Exe"
          
          # Test ZXPSignCmd (help command always returns non-zero, that's normal)
          & $Exe -help
          echo "ZXPSignCmd help completed (exit code $LASTEXITCODE is normal)"
          # Reset error state - help command exit codes are expected
          $Error.Clear()
          $LASTEXITCODE = 0

      - name: Restore signing cert
        shell: pwsh
        run: |
          [IO.File]::WriteAllBytes("cert.p12",[Convert]::FromBase64String($env:P12_BASE64))
          $certSize = (Get-Item "cert.p12").Length
          echo "Certificate file size: $certSize bytes"
          if ($certSize -lt 1000) { throw "Certificate file too small, likely corrupted" }
          
          echo "Certificate restored successfully ($certSize bytes)"
        env:
          P12_BASE64: ${{ secrets.ZXP_P12_BASE64 }}
          ZXP_P12_PASSWORD: ${{ secrets.ZXP_P12_PASSWORD }}

      - name: Sign all ZXP packages
        shell: pwsh
        run: |
          echo "=== Starting ZXP Signing Process ==="
          # Use the detected ZXPSignCmd version
          $versions = @("4.1.103", "4.1.102", "4.1.101", "4.1.100")
          $Exe = $null
          
          foreach ($version in $versions) {
            $testPath = "$env:GITHUB_WORKSPACE\CEP-Resources\ZXPSignCMD\$version\win64\ZXPSignCmd.exe"
            if (Test-Path $testPath) {
              $Exe = $testPath
              echo "Using ZXPSignCmd version: $version"
              break
            }
          }
          
          if (-not $Exe) { throw "ZXPSignCmd.exe not found in any version" }
          
          # Test certificate first
          echo "Certificate file exists: $(Test-Path "$env:GITHUB_WORKSPACE\cert.p12")"
          echo "Certificate size: $((Get-Item "$env:GITHUB_WORKSPACE\cert.p12").Length) bytes"
          
          # Check if CEP folders exist
          echo "AE Windows folder exists: $(Test-Path "$env:GITHUB_WORKSPACE\build\win\com.sync.extension.ae.panel")"
          echo "Premiere Windows folder exists: $(Test-Path "$env:GITHUB_WORKSPACE\build\win\com.sync.extension.ppro.panel")"
          echo "AE macOS folder exists: $(Test-Path "$env:GITHUB_WORKSPACE\build\mac\com.sync.extension.ae.panel")"
          echo "Premiere macOS folder exists: $(Test-Path "$env:GITHUB_WORKSPACE\build\mac\com.sync.extension.ppro.panel")"
          
          $certPath = "$env:GITHUB_WORKSPACE\cert.p12"
          $password = "${{ secrets.ZXP_P12_PASSWORD }}"
          
          # Create separate directories for each ZXP (each should contain only one panel)
          New-Item -ItemType Directory -Force -Path "build\zxp-ae-win" | Out-Null
          New-Item -ItemType Directory -Force -Path "build\zxp-ppro-win" | Out-Null
          New-Item -ItemType Directory -Force -Path "build\zxp-ae-mac" | Out-Null
          New-Item -ItemType Directory -Force -Path "build\zxp-ppro-mac" | Out-Null
          
          # Move panel contents to ZXP root (not in subdirectory)
          Copy-Item "$env:GITHUB_WORKSPACE\build\win\com.sync.extension.ae.panel\*" "build\zxp-ae-win\" -Recurse -Force
          Copy-Item "$env:GITHUB_WORKSPACE\build\win\com.sync.extension.ppro.panel\*" "build\zxp-ppro-win\" -Recurse -Force
          
          # Debug macOS source directories
          echo "Checking macOS source directories..."
          echo "AE macOS source exists: $(Test-Path "$env:GITHUB_WORKSPACE\build\mac\com.sync.extension.ae.panel")"
          echo "Premiere macOS source exists: $(Test-Path "$env:GITHUB_WORKSPACE\build\mac\com.sync.extension.ppro.panel")"
          echo "AE macOS server/.env exists: $(Test-Path "$env:GITHUB_WORKSPACE\build\mac\com.sync.extension.ae.panel\server\.env")"
          echo "Premiere macOS server/.env exists: $(Test-Path "$env:GITHUB_WORKSPACE\build\mac\com.sync.extension.ppro.panel\server\.env")"
          
          # List contents of macOS directories
          echo "Contents of AE macOS directory:"
          Get-ChildItem "$env:GITHUB_WORKSPACE\build\mac\com.sync.extension.ae.panel" | Select-Object Name, Length
          echo "Contents of Premiere macOS directory:"
          Get-ChildItem "$env:GITHUB_WORKSPACE\build\mac\com.sync.extension.ppro.panel" | Select-Object Name, Length
          
          # Copy macOS packages (server/.env will be copied as part of server/ directory)
          Copy-Item "$env:GITHUB_WORKSPACE\build\mac\com.sync.extension.ae.panel\*" "build\zxp-ae-mac\" -Recurse -Force
          Copy-Item "$env:GITHUB_WORKSPACE\build\mac\com.sync.extension.ppro.panel\*" "build\zxp-ppro-mac\" -Recurse -Force
          
          # Create mimetype file (must be first file in ZXP)
          $mimetypeContent = "application/vnd.adobe.air-ucf-package+zip"
          foreach ($zxpDir in @("build\zxp-ae-win", "build\zxp-ppro-win", "build\zxp-ae-mac", "build\zxp-ppro-mac")) {
            $mimetypePath = Join-Path $zxpDir "mimetype"
            # Use ASCII encoding without BOM for mimetype file
            $utf8NoBom = New-Object System.Text.UTF8Encoding $false
            [System.IO.File]::WriteAllText($mimetypePath, $mimetypeContent, $utf8NoBom)
            echo "Created mimetype file: $mimetypePath"
          }
          
          # Note: ZXPSignCmd will include the mimetype file in the ZXP
          # The mimetype file is created and will be included in the final ZXP
          echo "Mimetype files created in all ZXP directories"
          
          # Validate required files and set permissions
          foreach ($zxpDir in @("build\zxp-ae-win", "build\zxp-ppro-win", "build\zxp-ae-mac", "build\zxp-ppro-mac")) {
            echo "Validating $zxpDir..."
            
            # Check required files exist
            $mimetypePath = Join-Path $zxpDir "mimetype"
            if (-not (Test-Path $mimetypePath)) { 
              throw "Required file missing: $mimetypePath" 
            }
            
            # Check manifest.xml and index.html exist at ZXP root
            $manifestPath = Join-Path $zxpDir "CSXS\manifest.xml"
            $indexPath = Join-Path $zxpDir "index.html"
            $envPath = Join-Path $zxpDir "server\.env"
            if (-not (Test-Path $manifestPath)) {
              throw "Required manifest.xml missing: $manifestPath"
            }
            if (-not (Test-Path $indexPath)) {
              throw "Required index.html missing: $indexPath"
            }
            if (-not (Test-Path $envPath)) {
              throw "Required .env file missing: $envPath (server runs with cwd=server/, so .env must be in server/.env)"
            }
            echo "Found manifest.xml at: $manifestPath"
            echo "Found index.html at: $indexPath"
            echo "Found .env at: $envPath"
            
            # Validate .env contains required R2 variables
            $envContent = Get-Content $envPath -Raw
            if (-not ($envContent -match "R2_ENDPOINT_URL=") -or -not ($envContent -match "R2_ACCESS_KEY=") -or -not ($envContent -match "R2_SECRET_KEY=")) {
              throw ".env file missing required R2 configuration variables in $zxpDir"
            }
            if ($envContent -match "R2_ACCESS_KEY=$" -or $envContent -match "R2_SECRET_KEY=$") {
              throw ".env file contains empty R2 credentials in $zxpDir"
            }
            echo "✅ .env validation passed for $zxpDir"
            
            # Check Node.js binaries exist and set permissions (macOS only)
            if ($zxpDir -like "*mac*") {
              $nodeBinaries = Get-ChildItem -Path $zxpDir -Recurse -Name "node" -File
              if ($nodeBinaries.Count -eq 0) {
                throw "No Node.js binaries found in macOS package: $zxpDir"
              }
              foreach ($nodeBin in $nodeBinaries) {
                $fullPath = Join-Path $zxpDir $nodeBin
                echo "Setting execute permissions on: $fullPath"
                
                # Use attrib command to set archive bit (Windows equivalent of execute permission)
                attrib +A "$fullPath"
                
                # Also try setting via PowerShell file attributes
                $fileInfo = Get-Item $fullPath
                $fileInfo.Attributes = $fileInfo.Attributes -bor [System.IO.FileAttributes]::Archive
              }
            }
            
            echo "Validation completed for: $zxpDir"
          }
          
          # Define all packages to sign
          $packages = @(
            @{Input="$env:GITHUB_WORKSPACE\build\zxp-ae-win"; Output="$env:GITHUB_WORKSPACE\sync-extension-ae-windows-signed.zxp"; Name="AE Windows"; PanelDir="com.sync.extension.ae.panel"},
            @{Input="$env:GITHUB_WORKSPACE\build\zxp-ppro-win"; Output="$env:GITHUB_WORKSPACE\sync-extension-premiere-windows-signed.zxp"; Name="Premiere Windows"; PanelDir="com.sync.extension.ppro.panel"},
            @{Input="$env:GITHUB_WORKSPACE\build\zxp-ae-mac"; Output="$env:GITHUB_WORKSPACE\sync-extension-ae-mac-signed.zxp"; Name="AE macOS"; PanelDir="com.sync.extension.ae.panel"},
            @{Input="$env:GITHUB_WORKSPACE\build\zxp-ppro-mac"; Output="$env:GITHUB_WORKSPACE\sync-extension-premiere-mac-signed.zxp"; Name="Premiere macOS"; PanelDir="com.sync.extension.ppro.panel"}
          )
          
          # Sign each package
          foreach ($pkg in $packages) {
            echo "Signing $($pkg.Name)..."
            echo "Input: $($pkg.Input)"
            echo "Output: $($pkg.Output)"
            
            # Validate all required arguments are present
            if (-not (Test-Path $pkg.Input)) { throw "Input directory not found: $($pkg.Input)" }
            if (-not (Test-Path $certPath)) { throw "Certificate file not found: $certPath" }
            if ([string]::IsNullOrEmpty($password)) { throw "Password is empty" }
            
            # Ensure output directory exists
            $outputDir = Split-Path $pkg.Output -Parent
            if (-not (Test-Path $outputDir)) {
              New-Item -ItemType Directory -Force -Path $outputDir | Out-Null
            }
            
            # Convert paths to absolute and ensure proper formatting
            $inputPath = (Resolve-Path $pkg.Input).Path
            $outputPath = Join-Path $env:GITHUB_WORKSPACE (Split-Path $pkg.Output -Leaf)
            $certPathResolved = (Resolve-Path $certPath).Path
            
            echo "Resolved paths:"
            echo "  Input: $inputPath"
            echo "  Output: $outputPath"
            echo "  Cert: $certPathResolved"
            
            echo "All required arguments validated successfully for $($pkg.Name)"
            
            # Try signing - use quoted paths to handle spaces/special chars
            $tsaUrl = "${{ github.event.inputs.tsa_url }}"
            if ([string]::IsNullOrEmpty($tsaUrl)) {
              $tsaUrl = "http://timestamp.digicert.com"
            }
            
            # Call ZXPSignCmd with explicit path quoting
            $signArgs = @("-sign", "`"$inputPath`"", "`"$outputPath`"", "`"$certPathResolved`"", "`"$password`"", "-tsa", "`"$tsaUrl`"")
            & $Exe $signArgs
            if ($LASTEXITCODE -ne 0) { 
              echo "$($pkg.Name) signing with timestamp failed (exit $LASTEXITCODE), trying without timestamp..."
              $signArgsNoTSA = @("-sign", "`"$inputPath`"", "`"$outputPath`"", "`"$certPathResolved`"", "`"$password`"")
              & $Exe $signArgsNoTSA
              if ($LASTEXITCODE -ne 0) { throw "ZXPSignCmd failed for $($pkg.Name) with exit $LASTEXITCODE" }
            }
            echo "$($pkg.Name) signed successfully"
          }

      - name: Verify signatures
        shell: pwsh
        run: |
          # Use the detected ZXPSignCmd version
          $versions = @("4.1.103", "4.1.102", "4.1.101", "4.1.100")
          $Exe = $null
          
          foreach ($version in $versions) {
            $testPath = "$env:GITHUB_WORKSPACE\CEP-Resources\ZXPSignCMD\$version\win64\ZXPSignCmd.exe"
            if (Test-Path $testPath) {
              $Exe = $testPath
              echo "Using ZXPSignCmd version: $version"
              break
            }
          }
          
          if (-not $Exe) { throw "ZXPSignCmd.exe not found in any version" }
          
          $zxps = @(
            "sync-extension-ae-windows-signed.zxp",
            "sync-extension-premiere-windows-signed.zxp", 
            "sync-extension-ae-mac-signed.zxp",
            "sync-extension-premiere-mac-signed.zxp"
          )
          
          foreach ($zxp in $zxps) {
            echo "Verifying $zxp..."
            & $Exe -verify "$env:GITHUB_WORKSPACE\$zxp" -certinfo
            if ($LASTEXITCODE -ne 0) { throw "$zxp verify failed" }
            echo "$zxp verified successfully"
          }
          
          # Generate checksums for trust verification
          echo "Generating checksums for trust verification..."
          $checksums = @()
          foreach ($zxp in $zxps) {
            $filePath = "$env:GITHUB_WORKSPACE\$zxp"
            if (Test-Path $filePath) {
              $hash = Get-FileHash $filePath -Algorithm SHA256
              $checksum = "$($hash.Hash)  $zxp"
              $checksums += $checksum
              echo "SHA256: $checksum"
            }
          }
          
          # Write checksums to file
          $checksums | Out-File -FilePath "$env:GITHUB_WORKSPACE\checksums.txt" -Encoding UTF8
          echo "Checksums written to checksums.txt"
          
          # Note: Quarantine attributes are added by macOS when files are downloaded
          # Users need to remove them manually: xattr -d com.apple.provenance *.zxp
          echo "Note: If ZXP installer rejects the extension, remove quarantine attributes:"
          echo "xattr -d com.apple.provenance *.zxp"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: signed-zxp-packages
          path: |
            sync-extension-ae-windows-signed.zxp
            sync-extension-premiere-windows-signed.zxp
            sync-extension-ae-mac-signed.zxp
            sync-extension-premiere-mac-signed.zxp
            checksums.txt

      - name: Get tag message
        if: startsWith(github.ref, 'refs/tags/')
        id: tag_message
        shell: pwsh
        run: |
          $TAG_MESSAGE = git tag -l --format='%(contents)' ${{ github.ref_name }}
          echo "message<<EOF" >> $env:GITHUB_OUTPUT
          echo "$TAG_MESSAGE" >> $env:GITHUB_OUTPUT
          echo "EOF" >> $env:GITHUB_OUTPUT

      - name: Upload to GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          body: |
            ${{ steps.tag_message.outputs.message }}
            
            **Downloads:**
            - After Effects: `sync-extension-ae-windows-signed.zxp` and `sync-extension-ae-mac-signed.zxp`
            - Premiere Pro: `sync-extension-premiere-windows-signed.zxp` and `sync-extension-premiere-mac-signed.zxp`
            
            Choose the appropriate package for your platform and application.
            
            **Security & Trust:**
            - All packages are digitally signed and verified
            - SHA256 checksums are provided in `checksums.txt` for integrity verification
            - Verify checksums: `sha256sum -c checksums.txt` (Linux/macOS) or `certutil -hashfile <file> SHA256` (Windows)
          files: |
            sync-extension-ae-windows-signed.zxp
            sync-extension-premiere-windows-signed.zxp
            sync-extension-ae-mac-signed.zxp
            sync-extension-premiere-mac-signed.zxp
            checksums.txt
          draft: false
          prerelease: false
          generate_release_notes: true